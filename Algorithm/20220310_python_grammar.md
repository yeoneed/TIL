# 📝 코딩테스트를 위한 파이썬 문법
## 1️⃣ 자료형
### 🔷수 자료형
: 숫자 자료형(정수형, 실수형), 코딩 테스트에서 대부분은 정수형을 다루는 문제가 출제됨
#### 1. 정수형
양의 정수, 음의 정수, 0, **코딩테스트에서 출제되는 알고리즘 문제 대부분이 입력과 출력 데이터가 정수형임**
#### 2. 실수형
변수에 소수점을 붙임 수를 대입하면 실수형 변수
**< 소수부가 0이거나 정수부가 0인 소수는 0을 생략하고 작성할 수 있다. >**
```
a= 5. 
print(a) #a = 5.0 출력
a= -.7
print(a) #a = -0.7 출력
```
#### 2-1. (실수형) 지수 표현
e다음에 오는 수는 10의 지수부를 의미한다.  
예) 1e9: 1 * 10의 9제곱 = INF(무한대)의미로 사용  
예2) 
```
a = 75.25e1 #75.25 * 10의 1제곱
print(a) #a=752.5
```
```
a= 3954e-3  #3954 * 10^(-3) 즉 곱하기 10의 -3제곱
print(a) # a= 3.954
```
#### 2-2. 컴퓨터는 실수를 정확히 표현하지 못한다. 
```
a = 0.3 + 0.6
print(a)

if a ==0.9:
	print(True) #True, False 는"" 안씌워줘도 출력됨
else:
	print(False)
```
=> 따라서 소수점 값을 비교하는 작업이 필요한 문제라면 실수 값을 비교하지 못해서 원하는 결과를 얻지 못할 수 있다.  
=> 이럴때 round()함수 사용  

**round 함수**  
```
round(123.456,2) #=> 소수점 2번째 자리까지 반올림(=세번째 자리에서 반올림)
round(123.456) #=>소수점 첫째자리까지 반올림
```
#### 3. 수 자료형의 연산 
/: 나누기  
//: 몫 구하기  
%: 나머지 구하기  
**: 거듭제곱 구하기 <code>x ** y = x^y의 의미

### 🔷 리스트 자료형
: 파이썬 리스트 자료형은 내부적으로 '배열'을 채택, 연결리스트 자료구조 기능을 포함해서 **append(), remove()**등의 메서드를 지원한다. 

#### 1. 리스트 만들기
```
a= [1,2,3,4,5] #기본 형태
a = list() #빈 리스트 선언1
a = [] #빈 리스트 선언2
```
```
# 크기가 n이고 모든 값이 0인 1차원 리스트 초기화
n = 10
a = [0] * n
print(a)
```
#### 2. 리스트 인덱싱과 슬라이싱
1. 인덱싱: **인덱스값**(0부터 시작) 을 입력해 리스트의 **특정한 원소에 접근**하는 것
```
a = [1,2,3,4,5,6,7]
# 뒤에서 첫번째 원소 출력:
print(a[-1])

#뒤에서 세**번째** 원소 출력:
print(a[-3])

#네 **번째** 원소 값 변경:
a[3] = 7
print(a)
```  
  
2. 슬라이싱: [시작인덱스 : (끝인덱스-1) ] 형태

### 3. 리스트 컴프리핸션
= 리스트 초기화 하는 방법(긴 코드를 간략하게!)
```
#0부터 19까지의 수 중에서 홀수만 포함하는 리스트
array = [i for i in range(20) if i%2==1]
print(array)
```

```
#1부터 9까지 수의 제곱값을 포함하는 리스트
array = [i * i for i in range(1,10)]
print(array)
```
```
# 2차원 리스트 초기화 할 때 매우 용이
# 예) nxm 크기의 2차원 리스트 초기화
n = 3
m = 4
array = [[0]*m for _ in range(n)]
```
=> <code>언더바 " _ " 사용 이유</code>: 단순 반복을 위해!(변수 i,j 이런거의 **값 무시하고** 그냥 간단한 반복을 수행할 때 사용)
```
#n*m 크기의 2차원 리스트 초기화(잘못된 방법)
n = 3
m = 4
array = [[0] * m] * n #n=3개의 동일한 리스트 생성
print(array)

array[1][1] = 5 #다 같은 객체에서 나온 3개의 자료이므로 array[][1]=5가 됨
print(array)
```
=> 다 같은 객체에서 나온 3개의 자료이므로 array[][1]=5가 되는 것 중요!

#### 4. 리스트 관련 기타 메소드
책 424p: 메소드 별 시간 복잡도 정리
```
#특정 인덱스에 데이터 추가
a.insert(2,3) #인덱스2에 값 3추가
```
```
#특정 값 세기
print("값이 3인 데이터 개수:", a.count(3))
```
```
#특정 값 제거
print("값 1인 데이터 제거(두개 이상이면 한개만 제거)", a.remove(1))
```
* insert(삽입 위치 인덱스, 삽입할 값) - 삽입 후 원소 위치 조정: O(N)
* append(삽입할 값) - O(1)
* count(값) - O(N)
* remove(값)- O(N) 원소 위치 조정 때문에

### 🔷문자열 자료형
#### 1. 문자열 초기화
" ' ' " 혹은 ' " " ' 혹은 \'  혹은 \"' (백슬래쉬 사용)
#### 2. 문자열 연산
```
a = "hello"
b = "world"
print(a + " " + b)
```
```
a = "string"
print(a*3) #string 3번 출력
```
```
a = "abcdef"
print(a[2:4])
```
#### 3. 튜플 자료형
- 튜플: 한번 선언된 값을 변경할 수 없다. 
-  리스트 대괄호 이용, 튜플은 소괄호()이용
- 튜플은 대입해서 변경 불가-> `a[7] =2` 이런거 **안됨**=> 값 변경하면 안되는 우선순위 큐에 사용
- 각 원소의 성질이 서로 다를 때 주로 사용-> 다익스트라 (비용, 노드 번호) 

#### 4. 사전 자료형
: 키와 값을 쌍으로 가지는 자료형  
변경 불가능 한 값= '키'  
key, value 구성-> 해시 테이블 사용해서 시간 복잡도 O(1)
```
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'banana'
data['코코넛'] = 'coconut'
if '사과' in data:
	print("'사과'를 키로 가지는 데이터 존재")
```  
<br>
  
- 키/값만 뽑아서 **리스트로** 이용할 때
```
key_list = data.keys()
data_list = data.values()
```
<br>

- 각 키에 따른 값을 하나씩 출력
```
for key in key_list:
	print(data[key])
```
### 🔷집합 자료형
#### 1. 집합 자료형 소개
집합: 문자열 or 리스트 이용해서 생성 가능
- 집합 특징
	- 중복을 허용하지 않는다.
	- 순서가 없다. => 인덱싱으로 값을 얻을 수 없다. 
	- 키 존재 x, 값만 존재
	- 특정한 데이터가 이미 등장한 적이 있는지 여부 체크에 유리*(;검사 연산의 시간복잡도가 O(1)이기 때문에)*
	- set([])함수 혹은 { } 이용
```
data=set([1,2,3,4,5])
data = {1,2,3,4,5}
```
#### 2.  집합 자료형의 연산
- 합집합: |
- 교집합: &
- 차집합: -

#### 3. 집합 자료형 관련 함수
```
data= set([1,2,3]) #기본 집합
```

- add(): 새로운 원소 추가
```
data.add(4)
# {1,2,3,4} 
```
- update(): 여러 개의 값을 한꺼번에 추가
```
data.update([5,6]) # 여러개 추가할때는 리스트 []괄호를 사용하네!
# {1,2,3,4,5,6}
```
- remove(): 특정한 값 제거
```
data.remove(3)
# {1,2,4,5,6}
```
=> 모두 시간 복잡도 O(1): 왜? 인덱스 없어서 그런듯, 값에 바로 접근하고 기존 값들 위치 정렬할 필요가 없음
## 2️⃣ 조건문
### 🔷 비교 연산자
```
x>=y 
x<=y 
```
-> 등호 순서 주의! **두번째 오는 수 바로 옆에 = 붙임**
### 🔷 기타 연산자
- x in list: 리스트안에 x가 들어가 있을 때 true이다
- x not in 문자열: 문자열 안에 x가 들어가 있지 않을 때 true이다
- 조건문에서 pass 사용(아래 코드 o)
```
score = 90
if score>=90:
	pass # 나중에 작성할 소스코드
```
- 조건부 표현식(아래 코드 o)
```
score = 99
result = "success" if score>=80 else "Fail"
print(result)
```
```
a= [1,2,3,4,5,5,5]
remove_set = {3,5} 
result = [i for i in a if i not in remove_set]
print(result)
```
=> 조건 처리 할때는 리스트와 집합 혼용 가능함을 기억!

## 3️⃣ 반복문
### for 문
- for in 리스트/튜플/문자열 사용 가능
- for i in range(처음, 끝, 증감) 에서 `처음은 포함`, `끝은 불포함`, `증감은 마이너스여도 됨!`

## 4️⃣ 함수
: 동일한 알고리즘을 반복적으로 수행해야 할 때-> 함수 사용하면 매우 효율적: `왜?` 이거 안쓰면 매번 소스코드를 작성해야 하기 때문
```
# 함수 기본 형태
def 함수명(매개변수):
	실행할 소스코드
	return 반환값
# 매개변수, 반환값은 존재하지 않을수도 있다. 왜?
# 매개변수: main함수와 지정함수의 관계를 맺어주는 역할
# 반환값: 출력이 목적인 함수이면 없어도 됨
# return 기능: 값을 반환하거나 / 함수 빠져나가기
```
